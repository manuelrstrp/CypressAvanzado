<!doctype html>
<html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><meta name="viewport" content="width=device-width, initial-scale=1"/><title>Mochawesome Report</title><link rel="stylesheet" href="assets/app.css"/></head><body data-raw="{&quot;stats&quot;:{&quot;suites&quot;:3,&quot;tests&quot;:6,&quot;passes&quot;:5,&quot;pending&quot;:0,&quot;failures&quot;:1,&quot;testsRegistered&quot;:6,&quot;passPercent&quot;:83.33333333333333,&quot;pendingPercent&quot;:0,&quot;other&quot;:0,&quot;hasOther&quot;:false,&quot;skipped&quot;:0,&quot;hasSkipped&quot;:false,&quot;start&quot;:&quot;2023-05-16T20:17:48.787Z&quot;,&quot;end&quot;:&quot;2023-05-16T20:19:32.128Z&quot;,&quot;duration&quot;:103341},&quot;results&quot;:[{&quot;uuid&quot;:&quot;b274ac22-bdca-43f0-b05c-70a2d38a973b&quot;,&quot;title&quot;:&quot;&quot;,&quot;fullFile&quot;:&quot;cypress/e2e/features/navigation/navigation.feature&quot;,&quot;file&quot;:&quot;cypress/e2e/features/navigation/navigation.feature&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[],&quot;suites&quot;:[{&quot;uuid&quot;:&quot;ca5b1188-b43c-4779-bf7c-2c5b2c8c42a5&quot;,&quot;title&quot;:&quot;NavigationBar&quot;,&quot;fullFile&quot;:&quot;&quot;,&quot;file&quot;:&quot;&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;Navigate to the Feature Navigation Bar&quot;,&quot;fullTitle&quot;:&quot;NavigationBar Navigate to the Feature Navigation Bar&quot;,&quot;timedOut&quot;:null,&quot;duration&quot;:8829,&quot;state&quot;:&quot;failed&quot;,&quot;speed&quot;:null,&quot;pass&quot;:false,&quot;fail&quot;:true,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;var _a, _b, _c, _d, _e;\nconst { remainingSteps, testCaseStartedId } = retrieveInternalSpecProperties();\nif (context.messagesEnabled) {\n    taskTestCaseStarted({\n        id: testCaseStartedId,\n        testCaseId,\n        attempt: attempt++,\n        timestamp: (0, messages_1.createTimestamp)(),\n    });\n}\nwindow.testState = {\n    gherkinDocument,\n    pickles,\n    pickle,\n};\nfor (const step of steps) {\n    if (step.hook) {\n        const hook = step.hook;\n        cy.then(() =&gt; {\n            delete window.testState.pickleStep;\n            const start = (0, messages_1.createTimestamp)();\n            if (context.messagesEnabled) {\n                taskTestStepStarted({\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) =&gt; {\n            (0, cypress_1.runStepWithLogGroup)({\n                fn: () =&gt; registry.runHook(this, hook),\n                keyword: hook.keyword,\n                text: hook.tags,\n            });\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) =&gt; {\n            const end = (0, messages_1.createTimestamp)();\n            if (context.messagesEnabled) {\n                taskTestStepFinished({\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    testStepResult: {\n                        status: messages.TestStepResultStatus.PASSED,\n                        duration: (0, messages_1.duration)(start, end),\n                    },\n                    timestamp: end,\n                });\n            }\n            remainingSteps.shift();\n        });\n    }\n    else if (step.pickleStep) {\n        const pickleStep = step.pickleStep;\n        const text = (0, assertions_1.assertAndReturn)(pickleStep.text, \&quot;Expected pickle step to have a text\&quot;);\n        const scenarioStep = (0, assertions_1.assertAndReturn)(context.astIdsMap.get((0, assertions_1.assertAndReturn)((_a = pickleStep.astNodeIds) === null || _a === void 0 ? void 0 : _a[0], \&quot;Expected to find at least one astNodeId\&quot;)), `Expected to find scenario step associated with id = ${(_b = pickleStep.astNodeIds) === null || _b === void 0 ? void 0 : _b[0]}`);\n        const argument = ((_c = pickleStep.argument) === null || _c === void 0 ? void 0 : _c.dataTable)\n            ? new data_table_1.default(pickleStep.argument.dataTable)\n            : ((_e = (_d = pickleStep.argument) === null || _d === void 0 ? void 0 : _d.docString) === null || _e === void 0 ? void 0 : _e.content)\n                ? pickleStep.argument.docString.content\n                : undefined;\n        cy.then(() =&gt; {\n            window.testState.pickleStep = step.pickleStep;\n            internalProperties.currentStep = { pickleStep };\n            const start = (0, messages_1.createTimestamp)();\n            if (context.messagesEnabled) {\n                taskTestStepStarted({\n                    testStepId: pickleStep.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) =&gt; {\n            try {\n                return (0, cypress_1.runStepWithLogGroup)({\n                    keyword: (0, assertions_1.assertAndReturn)(\&quot;keyword\&quot; in scenarioStep &amp;&amp; scenarioStep.keyword, \&quot;Expected to find a keyword in the scenario step\&quot;),\n                    argument,\n                    text,\n                    fn: () =&gt; registry.runStepDefininition(this, text, argument),\n                }).then((result) =&gt; {\n                    return {\n                        start,\n                        result,\n                    };\n                });\n            }\n            catch (e) {\n                if (e instanceof registry_1.MissingDefinitionError) {\n                    throw new Error(createMissingStepDefinitionMessage(context, pickleStep, context.registry.parameterTypeRegistry));\n                }\n                else {\n                    throw e;\n                }\n            }\n        })\n            .then(({ start, result }) =&gt; {\n            var _a, _b, _c;\n            const end = (0, messages_1.createTimestamp)();\n            if (result === \&quot;pending\&quot;) {\n                if (context.messagesEnabled) {\n                    taskTestStepFinished({\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: messages.TestStepResultStatus.PENDING,\n                            duration: (0, messages_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    });\n                    remainingSteps.shift();\n                    for (const skippedStep of remainingSteps) {\n                        const testStepId = (0, assertions_1.assertAndReturn)((_b = (_a = skippedStep.hook) === null || _a === void 0 ? void 0 : _a.id) !== null &amp;&amp; _b !== void 0 ? _b : (_c = skippedStep.pickleStep) === null || _c === void 0 ? void 0 : _c.id, \&quot;Expected a step to either be a hook or a pickleStep\&quot;);\n                        taskTestStepStarted({\n                            testStepId,\n                            testCaseStartedId,\n                            timestamp: (0, messages_1.createTimestamp)(),\n                        });\n                        taskTestStepFinished({\n                            testStepId,\n                            testCaseStartedId,\n                            testStepResult: {\n                                status: messages.TestStepResultStatus.SKIPPED,\n                                duration: {\n                                    seconds: 0,\n                                    nanos: 0,\n                                },\n                            },\n                            timestamp: (0, messages_1.createTimestamp)(),\n                        });\n                    }\n                }\n                for (let i = 0, count = remainingSteps.length; i &lt; count; i++) {\n                    remainingSteps.pop();\n                }\n                cy.then(() =&gt; this.skip());\n            }\n            else {\n                if (context.messagesEnabled) {\n                    taskTestStepFinished({\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: messages.TestStepResultStatus.PASSED,\n                            duration: (0, messages_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    });\n                }\n                remainingSteps.shift();\n            }\n        });\n    }\n}&quot;,&quot;err&quot;:{&quot;message&quot;:&quot;AssertionError: Timed out retrying after 4000ms: Expected to find element: `#account_summary_tab`, but never found it.&quot;,&quot;estack&quot;:&quot;AssertionError: Timed out retrying after 4000ms: Expected to find element: `#account_summary_tab`, but never found it.\n    at LoginPage.validateSuccessLogin (webpack://avanzado/./cypress/pageObjects/LoginPage.js:31:0)\n    at Context.eval (webpack://avanzado/./cypress/e2e/features/navigation/navigation.js:10:0)\n    at Registry.runStepDefininition (webpack://avanzado/./node_modules/@badeball/cypress-cucumber-preprocessor/dist/registry.js:122:0)\n    at Object.fn (webpack://avanzado/./node_modules/@badeball/cypress-cucumber-preprocessor/dist/browser-runtime.js:297:0)\n    at runStepWithLogGroup (webpack://avanzado/./node_modules/@badeball/cypress-cucumber-preprocessor/dist/helpers/cypress.js:50:0)\n    at Context.eval (webpack://avanzado/./node_modules/@badeball/cypress-cucumber-preprocessor/dist/browser-runtime.js:293:0)&quot;,&quot;diff&quot;:null},&quot;uuid&quot;:&quot;ecbc84fe-817a-4771-9fbe-64fee9207eda&quot;,&quot;parentUUID&quot;:&quot;ca5b1188-b43c-4779-bf7c-2c5b2c8c42a5&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[],&quot;failures&quot;:[&quot;ecbc84fe-817a-4771-9fbe-64fee9207eda&quot;],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:8829,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:2000}],&quot;passes&quot;:[],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:0,&quot;root&quot;:true,&quot;rootEmpty&quot;:true,&quot;_timeout&quot;:2000},{&quot;uuid&quot;:&quot;c2a958a8-5fa0-4a42-bbbd-41d6add69fba&quot;,&quot;title&quot;:&quot;&quot;,&quot;fullFile&quot;:&quot;cypress/support/step_definitions/login/login.feature&quot;,&quot;file&quot;:&quot;cypress/support/step_definitions/login/login.feature&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[],&quot;suites&quot;:[{&quot;uuid&quot;:&quot;f14b9188-847c-4f11-b70c-553415b8e898&quot;,&quot;title&quot;:&quot;Login&quot;,&quot;fullFile&quot;:&quot;&quot;,&quot;file&quot;:&quot;&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;Login with valid credentials&quot;,&quot;fullTitle&quot;:&quot;Login Login with valid credentials&quot;,&quot;timedOut&quot;:null,&quot;duration&quot;:4192,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;var _a, _b, _c, _d, _e;\nconst { remainingSteps, testCaseStartedId } = retrieveInternalSpecProperties();\nif (context.messagesEnabled) {\n    taskTestCaseStarted({\n        id: testCaseStartedId,\n        testCaseId,\n        attempt: attempt++,\n        timestamp: (0, messages_1.createTimestamp)(),\n    });\n}\nwindow.testState = {\n    gherkinDocument,\n    pickles,\n    pickle,\n};\nfor (const step of steps) {\n    if (step.hook) {\n        const hook = step.hook;\n        cy.then(() =&gt; {\n            delete window.testState.pickleStep;\n            const start = (0, messages_1.createTimestamp)();\n            if (context.messagesEnabled) {\n                taskTestStepStarted({\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) =&gt; {\n            (0, cypress_1.runStepWithLogGroup)({\n                fn: () =&gt; registry.runHook(this, hook),\n                keyword: hook.keyword,\n                text: hook.tags,\n            });\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) =&gt; {\n            const end = (0, messages_1.createTimestamp)();\n            if (context.messagesEnabled) {\n                taskTestStepFinished({\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    testStepResult: {\n                        status: messages.TestStepResultStatus.PASSED,\n                        duration: (0, messages_1.duration)(start, end),\n                    },\n                    timestamp: end,\n                });\n            }\n            remainingSteps.shift();\n        });\n    }\n    else if (step.pickleStep) {\n        const pickleStep = step.pickleStep;\n        const text = (0, assertions_1.assertAndReturn)(pickleStep.text, \&quot;Expected pickle step to have a text\&quot;);\n        const scenarioStep = (0, assertions_1.assertAndReturn)(context.astIdsMap.get((0, assertions_1.assertAndReturn)((_a = pickleStep.astNodeIds) === null || _a === void 0 ? void 0 : _a[0], \&quot;Expected to find at least one astNodeId\&quot;)), `Expected to find scenario step associated with id = ${(_b = pickleStep.astNodeIds) === null || _b === void 0 ? void 0 : _b[0]}`);\n        const argument = ((_c = pickleStep.argument) === null || _c === void 0 ? void 0 : _c.dataTable)\n            ? new data_table_1.default(pickleStep.argument.dataTable)\n            : ((_e = (_d = pickleStep.argument) === null || _d === void 0 ? void 0 : _d.docString) === null || _e === void 0 ? void 0 : _e.content)\n                ? pickleStep.argument.docString.content\n                : undefined;\n        cy.then(() =&gt; {\n            window.testState.pickleStep = step.pickleStep;\n            internalProperties.currentStep = { pickleStep };\n            const start = (0, messages_1.createTimestamp)();\n            if (context.messagesEnabled) {\n                taskTestStepStarted({\n                    testStepId: pickleStep.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) =&gt; {\n            try {\n                return (0, cypress_1.runStepWithLogGroup)({\n                    keyword: (0, assertions_1.assertAndReturn)(\&quot;keyword\&quot; in scenarioStep &amp;&amp; scenarioStep.keyword, \&quot;Expected to find a keyword in the scenario step\&quot;),\n                    argument,\n                    text,\n                    fn: () =&gt; registry.runStepDefininition(this, text, argument),\n                }).then((result) =&gt; {\n                    return {\n                        start,\n                        result,\n                    };\n                });\n            }\n            catch (e) {\n                if (e instanceof registry_1.MissingDefinitionError) {\n                    throw new Error(createMissingStepDefinitionMessage(context, pickleStep, context.registry.parameterTypeRegistry));\n                }\n                else {\n                    throw e;\n                }\n            }\n        })\n            .then(({ start, result }) =&gt; {\n            var _a, _b, _c;\n            const end = (0, messages_1.createTimestamp)();\n            if (result === \&quot;pending\&quot;) {\n                if (context.messagesEnabled) {\n                    taskTestStepFinished({\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: messages.TestStepResultStatus.PENDING,\n                            duration: (0, messages_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    });\n                    remainingSteps.shift();\n                    for (const skippedStep of remainingSteps) {\n                        const testStepId = (0, assertions_1.assertAndReturn)((_b = (_a = skippedStep.hook) === null || _a === void 0 ? void 0 : _a.id) !== null &amp;&amp; _b !== void 0 ? _b : (_c = skippedStep.pickleStep) === null || _c === void 0 ? void 0 : _c.id, \&quot;Expected a step to either be a hook or a pickleStep\&quot;);\n                        taskTestStepStarted({\n                            testStepId,\n                            testCaseStartedId,\n                            timestamp: (0, messages_1.createTimestamp)(),\n                        });\n                        taskTestStepFinished({\n                            testStepId,\n                            testCaseStartedId,\n                            testStepResult: {\n                                status: messages.TestStepResultStatus.SKIPPED,\n                                duration: {\n                                    seconds: 0,\n                                    nanos: 0,\n                                },\n                            },\n                            timestamp: (0, messages_1.createTimestamp)(),\n                        });\n                    }\n                }\n                for (let i = 0, count = remainingSteps.length; i &lt; count; i++) {\n                    remainingSteps.pop();\n                }\n                cy.then(() =&gt; this.skip());\n            }\n            else {\n                if (context.messagesEnabled) {\n                    taskTestStepFinished({\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: messages.TestStepResultStatus.PASSED,\n                            duration: (0, messages_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    });\n                }\n                remainingSteps.shift();\n            }\n        });\n    }\n}&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;0e05ac53-4e29-4b21-94c7-267a58ef9dbc&quot;,&quot;parentUUID&quot;:&quot;f14b9188-847c-4f11-b70c-553415b8e898&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;0e05ac53-4e29-4b21-94c7-267a58ef9dbc&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:4192,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:2000}],&quot;passes&quot;:[],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:0,&quot;root&quot;:true,&quot;rootEmpty&quot;:true,&quot;_timeout&quot;:2000},{&quot;uuid&quot;:&quot;79a6e311-2e92-47c3-ad56-97a6c2142d75&quot;,&quot;title&quot;:&quot;&quot;,&quot;fullFile&quot;:&quot;cypress/e2e/features/loginOutline/loginOutline.feature&quot;,&quot;file&quot;:&quot;cypress/e2e/features/loginOutline/loginOutline.feature&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[],&quot;suites&quot;:[{&quot;uuid&quot;:&quot;3729f379-4d11-4145-a95a-1c73afd18c16&quot;,&quot;title&quot;:&quot;Login Outline&quot;,&quot;fullFile&quot;:&quot;&quot;,&quot;file&quot;:&quot;&quot;,&quot;beforeHooks&quot;:[],&quot;afterHooks&quot;:[],&quot;tests&quot;:[{&quot;title&quot;:&quot;Login with invalid credentials (example #1)&quot;,&quot;fullTitle&quot;:&quot;Login Outline Login with invalid credentials (example #1)&quot;,&quot;timedOut&quot;:null,&quot;duration&quot;:2624,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;var _a, _b, _c, _d, _e;\nconst { remainingSteps, testCaseStartedId } = retrieveInternalSpecProperties();\nif (context.messagesEnabled) {\n    taskTestCaseStarted({\n        id: testCaseStartedId,\n        testCaseId,\n        attempt: attempt++,\n        timestamp: (0, messages_1.createTimestamp)(),\n    });\n}\nwindow.testState = {\n    gherkinDocument,\n    pickles,\n    pickle,\n};\nfor (const step of steps) {\n    if (step.hook) {\n        const hook = step.hook;\n        cy.then(() =&gt; {\n            delete window.testState.pickleStep;\n            const start = (0, messages_1.createTimestamp)();\n            if (context.messagesEnabled) {\n                taskTestStepStarted({\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) =&gt; {\n            (0, cypress_1.runStepWithLogGroup)({\n                fn: () =&gt; registry.runHook(this, hook),\n                keyword: hook.keyword,\n                text: hook.tags,\n            });\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) =&gt; {\n            const end = (0, messages_1.createTimestamp)();\n            if (context.messagesEnabled) {\n                taskTestStepFinished({\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    testStepResult: {\n                        status: messages.TestStepResultStatus.PASSED,\n                        duration: (0, messages_1.duration)(start, end),\n                    },\n                    timestamp: end,\n                });\n            }\n            remainingSteps.shift();\n        });\n    }\n    else if (step.pickleStep) {\n        const pickleStep = step.pickleStep;\n        const text = (0, assertions_1.assertAndReturn)(pickleStep.text, \&quot;Expected pickle step to have a text\&quot;);\n        const scenarioStep = (0, assertions_1.assertAndReturn)(context.astIdsMap.get((0, assertions_1.assertAndReturn)((_a = pickleStep.astNodeIds) === null || _a === void 0 ? void 0 : _a[0], \&quot;Expected to find at least one astNodeId\&quot;)), `Expected to find scenario step associated with id = ${(_b = pickleStep.astNodeIds) === null || _b === void 0 ? void 0 : _b[0]}`);\n        const argument = ((_c = pickleStep.argument) === null || _c === void 0 ? void 0 : _c.dataTable)\n            ? new data_table_1.default(pickleStep.argument.dataTable)\n            : ((_e = (_d = pickleStep.argument) === null || _d === void 0 ? void 0 : _d.docString) === null || _e === void 0 ? void 0 : _e.content)\n                ? pickleStep.argument.docString.content\n                : undefined;\n        cy.then(() =&gt; {\n            window.testState.pickleStep = step.pickleStep;\n            internalProperties.currentStep = { pickleStep };\n            const start = (0, messages_1.createTimestamp)();\n            if (context.messagesEnabled) {\n                taskTestStepStarted({\n                    testStepId: pickleStep.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) =&gt; {\n            try {\n                return (0, cypress_1.runStepWithLogGroup)({\n                    keyword: (0, assertions_1.assertAndReturn)(\&quot;keyword\&quot; in scenarioStep &amp;&amp; scenarioStep.keyword, \&quot;Expected to find a keyword in the scenario step\&quot;),\n                    argument,\n                    text,\n                    fn: () =&gt; registry.runStepDefininition(this, text, argument),\n                }).then((result) =&gt; {\n                    return {\n                        start,\n                        result,\n                    };\n                });\n            }\n            catch (e) {\n                if (e instanceof registry_1.MissingDefinitionError) {\n                    throw new Error(createMissingStepDefinitionMessage(context, pickleStep, context.registry.parameterTypeRegistry));\n                }\n                else {\n                    throw e;\n                }\n            }\n        })\n            .then(({ start, result }) =&gt; {\n            var _a, _b, _c;\n            const end = (0, messages_1.createTimestamp)();\n            if (result === \&quot;pending\&quot;) {\n                if (context.messagesEnabled) {\n                    taskTestStepFinished({\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: messages.TestStepResultStatus.PENDING,\n                            duration: (0, messages_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    });\n                    remainingSteps.shift();\n                    for (const skippedStep of remainingSteps) {\n                        const testStepId = (0, assertions_1.assertAndReturn)((_b = (_a = skippedStep.hook) === null || _a === void 0 ? void 0 : _a.id) !== null &amp;&amp; _b !== void 0 ? _b : (_c = skippedStep.pickleStep) === null || _c === void 0 ? void 0 : _c.id, \&quot;Expected a step to either be a hook or a pickleStep\&quot;);\n                        taskTestStepStarted({\n                            testStepId,\n                            testCaseStartedId,\n                            timestamp: (0, messages_1.createTimestamp)(),\n                        });\n                        taskTestStepFinished({\n                            testStepId,\n                            testCaseStartedId,\n                            testStepResult: {\n                                status: messages.TestStepResultStatus.SKIPPED,\n                                duration: {\n                                    seconds: 0,\n                                    nanos: 0,\n                                },\n                            },\n                            timestamp: (0, messages_1.createTimestamp)(),\n                        });\n                    }\n                }\n                for (let i = 0, count = remainingSteps.length; i &lt; count; i++) {\n                    remainingSteps.pop();\n                }\n                cy.then(() =&gt; this.skip());\n            }\n            else {\n                if (context.messagesEnabled) {\n                    taskTestStepFinished({\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: messages.TestStepResultStatus.PASSED,\n                            duration: (0, messages_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    });\n                }\n                remainingSteps.shift();\n            }\n        });\n    }\n}&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;d391af16-3bf3-4d97-bcfe-edd75779abe4&quot;,&quot;parentUUID&quot;:&quot;3729f379-4d11-4145-a95a-1c73afd18c16&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;Login with invalid credentials (example #2)&quot;,&quot;fullTitle&quot;:&quot;Login Outline Login with invalid credentials (example #2)&quot;,&quot;timedOut&quot;:null,&quot;duration&quot;:1631,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;var _a, _b, _c, _d, _e;\nconst { remainingSteps, testCaseStartedId } = retrieveInternalSpecProperties();\nif (context.messagesEnabled) {\n    taskTestCaseStarted({\n        id: testCaseStartedId,\n        testCaseId,\n        attempt: attempt++,\n        timestamp: (0, messages_1.createTimestamp)(),\n    });\n}\nwindow.testState = {\n    gherkinDocument,\n    pickles,\n    pickle,\n};\nfor (const step of steps) {\n    if (step.hook) {\n        const hook = step.hook;\n        cy.then(() =&gt; {\n            delete window.testState.pickleStep;\n            const start = (0, messages_1.createTimestamp)();\n            if (context.messagesEnabled) {\n                taskTestStepStarted({\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) =&gt; {\n            (0, cypress_1.runStepWithLogGroup)({\n                fn: () =&gt; registry.runHook(this, hook),\n                keyword: hook.keyword,\n                text: hook.tags,\n            });\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) =&gt; {\n            const end = (0, messages_1.createTimestamp)();\n            if (context.messagesEnabled) {\n                taskTestStepFinished({\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    testStepResult: {\n                        status: messages.TestStepResultStatus.PASSED,\n                        duration: (0, messages_1.duration)(start, end),\n                    },\n                    timestamp: end,\n                });\n            }\n            remainingSteps.shift();\n        });\n    }\n    else if (step.pickleStep) {\n        const pickleStep = step.pickleStep;\n        const text = (0, assertions_1.assertAndReturn)(pickleStep.text, \&quot;Expected pickle step to have a text\&quot;);\n        const scenarioStep = (0, assertions_1.assertAndReturn)(context.astIdsMap.get((0, assertions_1.assertAndReturn)((_a = pickleStep.astNodeIds) === null || _a === void 0 ? void 0 : _a[0], \&quot;Expected to find at least one astNodeId\&quot;)), `Expected to find scenario step associated with id = ${(_b = pickleStep.astNodeIds) === null || _b === void 0 ? void 0 : _b[0]}`);\n        const argument = ((_c = pickleStep.argument) === null || _c === void 0 ? void 0 : _c.dataTable)\n            ? new data_table_1.default(pickleStep.argument.dataTable)\n            : ((_e = (_d = pickleStep.argument) === null || _d === void 0 ? void 0 : _d.docString) === null || _e === void 0 ? void 0 : _e.content)\n                ? pickleStep.argument.docString.content\n                : undefined;\n        cy.then(() =&gt; {\n            window.testState.pickleStep = step.pickleStep;\n            internalProperties.currentStep = { pickleStep };\n            const start = (0, messages_1.createTimestamp)();\n            if (context.messagesEnabled) {\n                taskTestStepStarted({\n                    testStepId: pickleStep.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) =&gt; {\n            try {\n                return (0, cypress_1.runStepWithLogGroup)({\n                    keyword: (0, assertions_1.assertAndReturn)(\&quot;keyword\&quot; in scenarioStep &amp;&amp; scenarioStep.keyword, \&quot;Expected to find a keyword in the scenario step\&quot;),\n                    argument,\n                    text,\n                    fn: () =&gt; registry.runStepDefininition(this, text, argument),\n                }).then((result) =&gt; {\n                    return {\n                        start,\n                        result,\n                    };\n                });\n            }\n            catch (e) {\n                if (e instanceof registry_1.MissingDefinitionError) {\n                    throw new Error(createMissingStepDefinitionMessage(context, pickleStep, context.registry.parameterTypeRegistry));\n                }\n                else {\n                    throw e;\n                }\n            }\n        })\n            .then(({ start, result }) =&gt; {\n            var _a, _b, _c;\n            const end = (0, messages_1.createTimestamp)();\n            if (result === \&quot;pending\&quot;) {\n                if (context.messagesEnabled) {\n                    taskTestStepFinished({\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: messages.TestStepResultStatus.PENDING,\n                            duration: (0, messages_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    });\n                    remainingSteps.shift();\n                    for (const skippedStep of remainingSteps) {\n                        const testStepId = (0, assertions_1.assertAndReturn)((_b = (_a = skippedStep.hook) === null || _a === void 0 ? void 0 : _a.id) !== null &amp;&amp; _b !== void 0 ? _b : (_c = skippedStep.pickleStep) === null || _c === void 0 ? void 0 : _c.id, \&quot;Expected a step to either be a hook or a pickleStep\&quot;);\n                        taskTestStepStarted({\n                            testStepId,\n                            testCaseStartedId,\n                            timestamp: (0, messages_1.createTimestamp)(),\n                        });\n                        taskTestStepFinished({\n                            testStepId,\n                            testCaseStartedId,\n                            testStepResult: {\n                                status: messages.TestStepResultStatus.SKIPPED,\n                                duration: {\n                                    seconds: 0,\n                                    nanos: 0,\n                                },\n                            },\n                            timestamp: (0, messages_1.createTimestamp)(),\n                        });\n                    }\n                }\n                for (let i = 0, count = remainingSteps.length; i &lt; count; i++) {\n                    remainingSteps.pop();\n                }\n                cy.then(() =&gt; this.skip());\n            }\n            else {\n                if (context.messagesEnabled) {\n                    taskTestStepFinished({\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: messages.TestStepResultStatus.PASSED,\n                            duration: (0, messages_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    });\n                }\n                remainingSteps.shift();\n            }\n        });\n    }\n}&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;a03279a2-2f4a-471d-9071-f91116a8a3f6&quot;,&quot;parentUUID&quot;:&quot;3729f379-4d11-4145-a95a-1c73afd18c16&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;Login with invalid credentials (example #3)&quot;,&quot;fullTitle&quot;:&quot;Login Outline Login with invalid credentials (example #3)&quot;,&quot;timedOut&quot;:null,&quot;duration&quot;:1596,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;var _a, _b, _c, _d, _e;\nconst { remainingSteps, testCaseStartedId } = retrieveInternalSpecProperties();\nif (context.messagesEnabled) {\n    taskTestCaseStarted({\n        id: testCaseStartedId,\n        testCaseId,\n        attempt: attempt++,\n        timestamp: (0, messages_1.createTimestamp)(),\n    });\n}\nwindow.testState = {\n    gherkinDocument,\n    pickles,\n    pickle,\n};\nfor (const step of steps) {\n    if (step.hook) {\n        const hook = step.hook;\n        cy.then(() =&gt; {\n            delete window.testState.pickleStep;\n            const start = (0, messages_1.createTimestamp)();\n            if (context.messagesEnabled) {\n                taskTestStepStarted({\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) =&gt; {\n            (0, cypress_1.runStepWithLogGroup)({\n                fn: () =&gt; registry.runHook(this, hook),\n                keyword: hook.keyword,\n                text: hook.tags,\n            });\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) =&gt; {\n            const end = (0, messages_1.createTimestamp)();\n            if (context.messagesEnabled) {\n                taskTestStepFinished({\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    testStepResult: {\n                        status: messages.TestStepResultStatus.PASSED,\n                        duration: (0, messages_1.duration)(start, end),\n                    },\n                    timestamp: end,\n                });\n            }\n            remainingSteps.shift();\n        });\n    }\n    else if (step.pickleStep) {\n        const pickleStep = step.pickleStep;\n        const text = (0, assertions_1.assertAndReturn)(pickleStep.text, \&quot;Expected pickle step to have a text\&quot;);\n        const scenarioStep = (0, assertions_1.assertAndReturn)(context.astIdsMap.get((0, assertions_1.assertAndReturn)((_a = pickleStep.astNodeIds) === null || _a === void 0 ? void 0 : _a[0], \&quot;Expected to find at least one astNodeId\&quot;)), `Expected to find scenario step associated with id = ${(_b = pickleStep.astNodeIds) === null || _b === void 0 ? void 0 : _b[0]}`);\n        const argument = ((_c = pickleStep.argument) === null || _c === void 0 ? void 0 : _c.dataTable)\n            ? new data_table_1.default(pickleStep.argument.dataTable)\n            : ((_e = (_d = pickleStep.argument) === null || _d === void 0 ? void 0 : _d.docString) === null || _e === void 0 ? void 0 : _e.content)\n                ? pickleStep.argument.docString.content\n                : undefined;\n        cy.then(() =&gt; {\n            window.testState.pickleStep = step.pickleStep;\n            internalProperties.currentStep = { pickleStep };\n            const start = (0, messages_1.createTimestamp)();\n            if (context.messagesEnabled) {\n                taskTestStepStarted({\n                    testStepId: pickleStep.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) =&gt; {\n            try {\n                return (0, cypress_1.runStepWithLogGroup)({\n                    keyword: (0, assertions_1.assertAndReturn)(\&quot;keyword\&quot; in scenarioStep &amp;&amp; scenarioStep.keyword, \&quot;Expected to find a keyword in the scenario step\&quot;),\n                    argument,\n                    text,\n                    fn: () =&gt; registry.runStepDefininition(this, text, argument),\n                }).then((result) =&gt; {\n                    return {\n                        start,\n                        result,\n                    };\n                });\n            }\n            catch (e) {\n                if (e instanceof registry_1.MissingDefinitionError) {\n                    throw new Error(createMissingStepDefinitionMessage(context, pickleStep, context.registry.parameterTypeRegistry));\n                }\n                else {\n                    throw e;\n                }\n            }\n        })\n            .then(({ start, result }) =&gt; {\n            var _a, _b, _c;\n            const end = (0, messages_1.createTimestamp)();\n            if (result === \&quot;pending\&quot;) {\n                if (context.messagesEnabled) {\n                    taskTestStepFinished({\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: messages.TestStepResultStatus.PENDING,\n                            duration: (0, messages_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    });\n                    remainingSteps.shift();\n                    for (const skippedStep of remainingSteps) {\n                        const testStepId = (0, assertions_1.assertAndReturn)((_b = (_a = skippedStep.hook) === null || _a === void 0 ? void 0 : _a.id) !== null &amp;&amp; _b !== void 0 ? _b : (_c = skippedStep.pickleStep) === null || _c === void 0 ? void 0 : _c.id, \&quot;Expected a step to either be a hook or a pickleStep\&quot;);\n                        taskTestStepStarted({\n                            testStepId,\n                            testCaseStartedId,\n                            timestamp: (0, messages_1.createTimestamp)(),\n                        });\n                        taskTestStepFinished({\n                            testStepId,\n                            testCaseStartedId,\n                            testStepResult: {\n                                status: messages.TestStepResultStatus.SKIPPED,\n                                duration: {\n                                    seconds: 0,\n                                    nanos: 0,\n                                },\n                            },\n                            timestamp: (0, messages_1.createTimestamp)(),\n                        });\n                    }\n                }\n                for (let i = 0, count = remainingSteps.length; i &lt; count; i++) {\n                    remainingSteps.pop();\n                }\n                cy.then(() =&gt; this.skip());\n            }\n            else {\n                if (context.messagesEnabled) {\n                    taskTestStepFinished({\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: messages.TestStepResultStatus.PASSED,\n                            duration: (0, messages_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    });\n                }\n                remainingSteps.shift();\n            }\n        });\n    }\n}&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;7c050d1e-427b-4c20-9c51-add534823d1f&quot;,&quot;parentUUID&quot;:&quot;3729f379-4d11-4145-a95a-1c73afd18c16&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false},{&quot;title&quot;:&quot;Login with invalid credentials (example #4)&quot;,&quot;fullTitle&quot;:&quot;Login Outline Login with invalid credentials (example #4)&quot;,&quot;timedOut&quot;:null,&quot;duration&quot;:2580,&quot;state&quot;:&quot;passed&quot;,&quot;speed&quot;:&quot;fast&quot;,&quot;pass&quot;:true,&quot;fail&quot;:false,&quot;pending&quot;:false,&quot;context&quot;:null,&quot;code&quot;:&quot;var _a, _b, _c, _d, _e;\nconst { remainingSteps, testCaseStartedId } = retrieveInternalSpecProperties();\nif (context.messagesEnabled) {\n    taskTestCaseStarted({\n        id: testCaseStartedId,\n        testCaseId,\n        attempt: attempt++,\n        timestamp: (0, messages_1.createTimestamp)(),\n    });\n}\nwindow.testState = {\n    gherkinDocument,\n    pickles,\n    pickle,\n};\nfor (const step of steps) {\n    if (step.hook) {\n        const hook = step.hook;\n        cy.then(() =&gt; {\n            delete window.testState.pickleStep;\n            const start = (0, messages_1.createTimestamp)();\n            if (context.messagesEnabled) {\n                taskTestStepStarted({\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) =&gt; {\n            (0, cypress_1.runStepWithLogGroup)({\n                fn: () =&gt; registry.runHook(this, hook),\n                keyword: hook.keyword,\n                text: hook.tags,\n            });\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) =&gt; {\n            const end = (0, messages_1.createTimestamp)();\n            if (context.messagesEnabled) {\n                taskTestStepFinished({\n                    testStepId: hook.id,\n                    testCaseStartedId,\n                    testStepResult: {\n                        status: messages.TestStepResultStatus.PASSED,\n                        duration: (0, messages_1.duration)(start, end),\n                    },\n                    timestamp: end,\n                });\n            }\n            remainingSteps.shift();\n        });\n    }\n    else if (step.pickleStep) {\n        const pickleStep = step.pickleStep;\n        const text = (0, assertions_1.assertAndReturn)(pickleStep.text, \&quot;Expected pickle step to have a text\&quot;);\n        const scenarioStep = (0, assertions_1.assertAndReturn)(context.astIdsMap.get((0, assertions_1.assertAndReturn)((_a = pickleStep.astNodeIds) === null || _a === void 0 ? void 0 : _a[0], \&quot;Expected to find at least one astNodeId\&quot;)), `Expected to find scenario step associated with id = ${(_b = pickleStep.astNodeIds) === null || _b === void 0 ? void 0 : _b[0]}`);\n        const argument = ((_c = pickleStep.argument) === null || _c === void 0 ? void 0 : _c.dataTable)\n            ? new data_table_1.default(pickleStep.argument.dataTable)\n            : ((_e = (_d = pickleStep.argument) === null || _d === void 0 ? void 0 : _d.docString) === null || _e === void 0 ? void 0 : _e.content)\n                ? pickleStep.argument.docString.content\n                : undefined;\n        cy.then(() =&gt; {\n            window.testState.pickleStep = step.pickleStep;\n            internalProperties.currentStep = { pickleStep };\n            const start = (0, messages_1.createTimestamp)();\n            if (context.messagesEnabled) {\n                taskTestStepStarted({\n                    testStepId: pickleStep.id,\n                    testCaseStartedId,\n                    timestamp: start,\n                });\n            }\n            return cy.wrap(start, { log: false });\n        })\n            .then((start) =&gt; {\n            try {\n                return (0, cypress_1.runStepWithLogGroup)({\n                    keyword: (0, assertions_1.assertAndReturn)(\&quot;keyword\&quot; in scenarioStep &amp;&amp; scenarioStep.keyword, \&quot;Expected to find a keyword in the scenario step\&quot;),\n                    argument,\n                    text,\n                    fn: () =&gt; registry.runStepDefininition(this, text, argument),\n                }).then((result) =&gt; {\n                    return {\n                        start,\n                        result,\n                    };\n                });\n            }\n            catch (e) {\n                if (e instanceof registry_1.MissingDefinitionError) {\n                    throw new Error(createMissingStepDefinitionMessage(context, pickleStep, context.registry.parameterTypeRegistry));\n                }\n                else {\n                    throw e;\n                }\n            }\n        })\n            .then(({ start, result }) =&gt; {\n            var _a, _b, _c;\n            const end = (0, messages_1.createTimestamp)();\n            if (result === \&quot;pending\&quot;) {\n                if (context.messagesEnabled) {\n                    taskTestStepFinished({\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: messages.TestStepResultStatus.PENDING,\n                            duration: (0, messages_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    });\n                    remainingSteps.shift();\n                    for (const skippedStep of remainingSteps) {\n                        const testStepId = (0, assertions_1.assertAndReturn)((_b = (_a = skippedStep.hook) === null || _a === void 0 ? void 0 : _a.id) !== null &amp;&amp; _b !== void 0 ? _b : (_c = skippedStep.pickleStep) === null || _c === void 0 ? void 0 : _c.id, \&quot;Expected a step to either be a hook or a pickleStep\&quot;);\n                        taskTestStepStarted({\n                            testStepId,\n                            testCaseStartedId,\n                            timestamp: (0, messages_1.createTimestamp)(),\n                        });\n                        taskTestStepFinished({\n                            testStepId,\n                            testCaseStartedId,\n                            testStepResult: {\n                                status: messages.TestStepResultStatus.SKIPPED,\n                                duration: {\n                                    seconds: 0,\n                                    nanos: 0,\n                                },\n                            },\n                            timestamp: (0, messages_1.createTimestamp)(),\n                        });\n                    }\n                }\n                for (let i = 0, count = remainingSteps.length; i &lt; count; i++) {\n                    remainingSteps.pop();\n                }\n                cy.then(() =&gt; this.skip());\n            }\n            else {\n                if (context.messagesEnabled) {\n                    taskTestStepFinished({\n                        testStepId: pickleStep.id,\n                        testCaseStartedId,\n                        testStepResult: {\n                            status: messages.TestStepResultStatus.PASSED,\n                            duration: (0, messages_1.duration)(start, end),\n                        },\n                        timestamp: end,\n                    });\n                }\n                remainingSteps.shift();\n            }\n        });\n    }\n}&quot;,&quot;err&quot;:{},&quot;uuid&quot;:&quot;3f97d053-5002-4518-b4cd-21e241ad4652&quot;,&quot;parentUUID&quot;:&quot;3729f379-4d11-4145-a95a-1c73afd18c16&quot;,&quot;isHook&quot;:false,&quot;skipped&quot;:false}],&quot;suites&quot;:[],&quot;passes&quot;:[&quot;d391af16-3bf3-4d97-bcfe-edd75779abe4&quot;,&quot;a03279a2-2f4a-471d-9071-f91116a8a3f6&quot;,&quot;7c050d1e-427b-4c20-9c51-add534823d1f&quot;,&quot;3f97d053-5002-4518-b4cd-21e241ad4652&quot;],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:8431,&quot;root&quot;:false,&quot;rootEmpty&quot;:false,&quot;_timeout&quot;:2000}],&quot;passes&quot;:[],&quot;failures&quot;:[],&quot;pending&quot;:[],&quot;skipped&quot;:[],&quot;duration&quot;:0,&quot;root&quot;:true,&quot;rootEmpty&quot;:true,&quot;_timeout&quot;:2000}],&quot;meta&quot;:{&quot;mocha&quot;:{&quot;version&quot;:&quot;7.0.1&quot;},&quot;mochawesome&quot;:{&quot;options&quot;:{&quot;quiet&quot;:false,&quot;reportFilename&quot;:&quot;mochawesome&quot;,&quot;saveHtml&quot;:false,&quot;saveJson&quot;:true,&quot;consoleReporter&quot;:&quot;spec&quot;,&quot;useInlineDiffs&quot;:false,&quot;code&quot;:true},&quot;version&quot;:&quot;7.1.3&quot;},&quot;marge&quot;:{&quot;options&quot;:{&quot;id&quot;:&quot;default&quot;,&quot;reportDir&quot;:&quot;cypress/results/mochawesome&quot;,&quot;overwrite&quot;:false,&quot;html&quot;:false,&quot;json&quot;:true},&quot;version&quot;:&quot;6.2.0&quot;}}}" data-config="{&quot;reportFilename&quot;:&quot;mochawesome&quot;,&quot;reportDir&quot;:&quot;mochawesome-report&quot;,&quot;reportTitle&quot;:&quot;avanzado&quot;,&quot;reportPageTitle&quot;:&quot;Mochawesome Report&quot;,&quot;inline&quot;:false,&quot;inlineAssets&quot;:false,&quot;cdn&quot;:false,&quot;charts&quot;:false,&quot;enableCharts&quot;:false,&quot;code&quot;:true,&quot;enableCode&quot;:true,&quot;autoOpen&quot;:false,&quot;overwrite&quot;:true,&quot;timestamp&quot;:false,&quot;ts&quot;:false,&quot;showPassed&quot;:true,&quot;showFailed&quot;:true,&quot;showPending&quot;:true,&quot;showSkipped&quot;:false,&quot;showHooks&quot;:&quot;failed&quot;,&quot;saveJson&quot;:false,&quot;saveHtml&quot;:true,&quot;dev&quot;:false,&quot;assetsDir&quot;:&quot;mochawesome-report/assets&quot;,&quot;htmlFile&quot;:&quot;/Users/macbookpro/Desktop/Programing/AutomationQA/Cypress/avanzado/mochawesome-report/mochawesome.html&quot;}"><div id="report"></div><script src="assets/app.js"></script></body></html>